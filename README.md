# peripheral_dev_tst

# Table of Contents
* [Introduction](#Introduction)
	* [why C ?](#why-C-?)
* [general remarks ](#general-remarks-)
	* [compile / building / eclipse ](#compile-/-building-/-eclipse-)
	* [(i2c) error handling](#(i2c)-error-handling)
	* [the getVersion class](#the-getVersion-class)
* [the Devices](#the-Devices)
	* [ADC101_xx](#ADC101_xx)
	* [AT30TSE752](#AT30TSE752)
	* [HTS221](#HTS221)
	* [LTC2533 ](#LTC2533-)
	* [MCP23009](#MCP23009)
	* [MCP4725](#MCP4725)
	* [MCP4728_tst](#MCP4728_tst)
	* [VEML7700_tst](#VEML7700_tst)
* [MBED](#MBED)
	* [preparations](#preparations)
	* [generating the programming files](#generating-the-programming-files)
* [dummy  Linux](#dummy--Linux)
* [linux i2c dev ](#linux-i2c-dev-)
	* [directories ](#directories-)
* [raspberry PI](#raspberry-PI)
* [raspberry PI pico]((# raspberry PI pico) 
* [other considered platforms ](#other-considered-platforms-)




(TOC generated by https://pypi.org/project/markdown-toc/#Usage  <br>
markdown_toc.py -t github  README.md
)

## versions 

In most of the cases commits happens after adding a new platform or new devices 
Check the commit comments what was the last commit for the platform you want to use . 
tags 
v1.0  is used to get a reference for the code that is compatible for mbed2 ,but this platform is not mantained 
after V1.0 only mbed_os version >4  is supported for the MBED compatible hardware 






## Introduction

Test program for the  i2c devices in PerDevices repository <br>


In the chapter MBED and dummy Linux it is explained how to install the code for the corresponding platform. 


For most of the devices I have a PCB design. Let me know if you are interested. This is also the main drive for this project.  In several setup the same reqiuirement to measure temperature, pressure etc. are needed (outside the "main" pcb.  The same for (not enginering ) student projects. In this way they can easiliy adopt the device code on different plaforms without going in to much detail of the device.<br>
This repository support different platforms. But the aim of this project is not to have a "general"  development environment for applications. In my view to use the device you use will be:   connect the device to yuour platform ->  check with the sample program if it works ->  transfer / copy the device code to your application .
Off course the example code and cmake can be used as insperation how to get your application running .


A number of these devices are used in one or more experiments of test setups.<br> 
By example the SOLID experiment : http://solid-experiment.org/ 

All the devices use a pointer to an abstract I2C class so it easy to reuse. 

In general I try to give references to code I copied or that I used as base for the development of the code.  But in the heat of getting it ready sometimes I copied code without keeping track where I got it from.  So in case you think you are the original author of some code please let me know. ( via github) . 


### why C ?
These days a lot of projects use python.  But very simple platforms will not support this. Still I use C++ (and not C) as this gives a better to understand code<br> 
The platforms I use all support C++


## general remarks 

### compile / building / eclipse 

For the MBED platform the MBED-cli (on windows )  is used, see below more.
For the Linux based plaforms cmake is used. The cmake tries to figure out what is the most likely hardware is available. If nothing is found a dummy interface is used. This dummy is mainly indented for development. <br> 
I don't forsee  to support crossplaform compilation <br>
Original the MBED online compiler was used so it was already a good development platform<br>
I consider to use eclipese. But with multi plaforms I have no experience  so I didn't take the step yet<br> 



### (i2c) error handling

For the moment error handling is done by the return code of the I2cInterface  class.<br>
Each method generate a negative value in case of an error. <br>
This is not very easy to use in general code. <br> 
As all the platforms I consider ( so including mbed) all support C++.  Plan is to use exceptions for I2C related errors ( like not implemented functions)<br> 
For simple platforms , adrino , mbed exceptions are not very useful during run time as these  are ofted used to control systems , often stand alone. Preferable it could be "switch off"  with cmake to minimize the code complexity  but not yet figure out how to this in a nice way. The exceptions would be used during development ( and of course of platforms like a raspberry-PI ) 

There is a class DevErrorReporter , inherited by the I2CInterface class.  The I2CInterface implementation can use this to get the status of the last error . So the main program can use the methods to debug .  


### the getVersion class

All the code inherit a getVersion class.  With this class you cab get the version  and compile time. I use this in the projects at the start as printout . This helps to trace back why a "update"  is not working . As the code is used in several projects sometimes a change is  not backwards compatible. In the past ( > 5 years) ago I have used a lib for this but that was very complex as it was covering much more than what I need. 


## the Devices
Below a short description of the devices. <br>
Most devices are tested with the  FRDM-KL05Z or FRDM-KL25Z  ( MBED ) platform. 

Please check the date of the last commit of this file. <br>
The links to the data info from the manufactures could be outdated ( my experience is the manufactures change  their websites almost every year or the merge with others ) 

### ADC101_xx
 
10 bits ADC  189kSPS  1 CH  <br>
This is for a whole series of ADC's from Texas Instruments.  <br>
It is only tested with adc101c021  .  <br>
http://www.ti.com/product/ADC101C021

### AT30TSE752

This is a cheap temperature sensor with eeprom with a wide voltage range.  <br>
I used the eeprom by example to store calibration values and device ID's . <br>
When I used them ( > 300)  for the SOLID experiment it was still Atmel.  Now it is taken over by Micro chip  <br>
The AT30TSE752 is obsolete but the AT30TSE752A is still available. I used both   <br>
I have problems with locking and /or unlocking the eeprom contents.  It sometimes fails and seems not recoverable ( so if locked , you can not unlock it anymore) 


### HTS221

A humidity and temperature sensor from st  ( st.com ) <br>
https://www.st.com/content/st_com/en/products/mems-and-sensors/humidity-sensors/hts221.html

For the price it is a good sensor , we use it in the SOLID experiment to monitor humidity and temperatures on several places.  <br>
Pitty the package can not (at all ?) soldered manual. But as we used many of this I had to make a small PCB.  

### LTC2533 

A DAC   from 8 to 12 bits depending on the ordering. 
Data sheet https://www.analog.com/en/products/ltc2633.html
Will be used for a student project  . 


### MCP23009

I2C IO extender . 5.5 V tolerant  <br>
Micro chip .  <br>
https://www.microchip.com/wwwproducts/en/MCP23009

Not sure I used this device.

### MCP4725

DAC  12 bits resolution  1 channel  On-Board Non-Volatile Memory (EEPROM)   <br>
The EEPROM is very useful to get a working starting point for a device without any software needed.  <br>
web site (micro chip ) <br>
https://www.microchip.com/wwwproducts/en/en532229

### MCP4728_tst

DAC 28 bits  4 channels,  On-Board Non-Volatile Memory (EEPROM)  <br>
https://www.microchip.com/wwwproducts/en/en541737
 
The address can be set by programming.  For the MBED on-line compiler this is supported but not (yet) for this version as also IO pins and interrupt are needed.
if you want to program the I2C address check this  project<br>
https://os.mbed.com/users/wbeaumont/code/MCP4728test/

Be sure you select the correct pins for the IO.  

### VEML7700_tst

Lux meter :  https://www.vishay.com/ppg?84286

tested on the KL05Z  , most functions are in.  No detailed power mode handling 
also included function that calculates the lux. 




## MBED

These are simple test programs  for the devices in the repository https://github.com/wimbeaumont/PerDevices

This repository contains classes for the I2C devices and I2C abstraction classes. 

To generate the files to download to the device the   mbed-cli is used <br>. 
MBED os  6.3  ( the latest at this moment)  As I use python 3  older MBED version ( < 5.x )  are not supported  

Assumed is that the \_\_MBED\_\_ variable is set. This is used to include / define MBED specific code 


### preparations

Worked on windows 7

   * git was already installed 
   * Installed python3  
   * installed mercurial 
   * run Mbed_installer_v0.4.10.exe   (mbed-cli ) , problem is this installs python2 and set it as default. 
   

Below the description to handle multi projects ( as each test is a project) 

C:\Users\SomeUser\My Documents\mbed_cli   is the projdir<br>
( the location of the project directory is not important as long you have all the access rights) 

in the projdir git clone 

git clone https://github.com/wimbeaumont/PeripheralDevices.git
   
git clone https://github.com/wimbeaumont/peripheral_dev_tst.git

In the projdir  :   mbed import mbed-os
  
set the globals  
mbed config -G MBED_OS_DIR mbed-os
 
So the .mbed is now 
( this is in the users home directory so  C:\Users\SomeUser\\.mbed ) 
 
---
 
GCC_ARM_PATH=C:\Program Files (x86)\GNU Tools ARM Embedded\6 2017-q2-update\bin <br>
TOOLCHAIN=GCC_ARM<br>
ARM_PATH=C:\Program Files (x86)\GNU Tools ARM Embedded\6 2017-q2-update\bin<br>
MBED_OS_DIR=C:\Users\wimb\My Documents\mbed_cli\mbed-os<br>

--- 

### generating the programming files

now  prepare the mbed project 

cd peripheral_dev_tst 

C:\Users\SomeUser\My Documents\mbed_cli\peripheral_dev_tst>mbed new ADC101_xx_tst -scm none 

(is  mbed new  really needed ?  the --scm none is to avoid the .git is overwritten ) 

**now compile for MBED**

in projdir

mbed compile -m KL25Z --source peripheral_dev_tst/ADC101_xx_tst --source PeripheralDevices --source mbed-os --build BUILD/ADC101_xx_tst<br>
not tested with the ADC101  but the KL25Z responds correctly 

mbed compile -m KL25Z --source peripheral_dev_tst/MCP4725_tst --source PeripheralDevices --source mbed-os --build BUILD/MCP4725_tst<br>
not tested with the MCP4725  but the KL25Z responds 

As you notice in the last case the is not made a new mbed project. So not so clear if you have to do it at all as with the paramters and global settings you almost define all needed. 


in the same way :  (most not verified  on the target ) 

mbed compile -m KL25Z --source peripheral_dev_tst/HTS221_tst --source PeripheralDevices --source mbed-os --build BUILD/HTS221_tst

mbed compile -m KL25Z --source peripheral_dev_tst/AT30TSE752_tst --source PeripheralDevices --source mbed-os --build BUILD/AT30TSE752_tst

mbed compile -m KL25Z --source peripheral_dev_tst/MCP4728_tst --source PeripheralDevices --source mbed-os --build BUILD/MCP4728_tst

mbed compile -m KL25Z --source peripheral_dev_tst/MCP23009_tst --source PeripheralDevices --source mbed-os --build BUILD/MCP23009_tst

This method will most likely not work for the FRDM-KL05Z as this device is not supported for mbed os > 2.x 
Perhaps it works when using python 2.7 

for more info this is a nice page: 

https://os.mbed.com/docs/mbed-os/v5.12/tools/working-with-mbed-cli.html

Most of  the MBED enabled devices I used are the FRDM KL25Z  and FRDM KL05Z  mainly as sensor readout interface for projects. These projects runs on Linux machines.  But connecting these devices ( and perhaps other MBED platforms ) don't work nicely with Windows 10.  Seems I have now one FRDM KL25Z connecting "stable" to windows 10.  See my FRDM on Windows 10 readme. 



## dummy  Linux

This is a version to compile / develop with a full develop system ( standard linux desktop environment) <br> 
Tested with CentOs  7

Uses cmake to generate the test programs.  If no hardware ( means /dev/i2c-?) is found the the cmake file will prepare for  the dummy device 


go to the build  directory<br>
there  $>cmake ../cmake/CMakeLists.txt   -DDUMMY=true <br> 
then  $>make  all<br> 
or  $>make MCP4725_tst   ( or other device ) 

to remove all compiled files , $>make clean 
to start clean you can remove all files in the build directory ( except the .gitignore file).  So rm * 
and rm -rf CMakeFiles




## linux i2c dev 
If the /dev/i2c-1 is found the make file will generate the make file.  This is hard coded in the cmake so you have to edit this if you want to use an other device.

There is a name clash of the dev read/ write function  and the I2CInterface (same name and parameters) .  To solve this I created a LinuxI2c class that handles the hardware access. 

pitfall :  if you do first $>cmake .  -DDUMMY=true   , then use   >cmake .  -DDUMMY=false , because cmake keep the value in the  cache . 

As I have no Linux computers interface with I2C I can only test it on Raspberry Pi 

Since April 2020  also the  "register read" function is implemented,  this is   Addres Writer , register(byte only)  RESTART  AdressRead , read data  STOP.  So there is no stop between the write and read. 

Also you have to add the user to the i2c groupr sudo usermod  -aG i2c digpr 

### directories 


I made a directory ~/Pdev .  In this directory:

git clone git@github.com:wimbeaumont/peripheral_dev_tst.git <br>
git clone git@github.com:wimbeaumont/PeripheralDevices.git <br>

( I have a ssh key on my github account) 

cd ~/Pdev/peripheral_dev_tst/cmake<br>
cmake .  ( notice the . ) 

Then the test programs should be compiled with 
make ( in the cmake directorie) 




## raspberry PI  

cmake is not defaul installed on the Raspberry Pi so you have to install it.  In the documentation there are also remarks that you have to activate the I2C device  ( but for the once I have it was always the case ).
to activate the i2c interface https://www.raspberrypi-spy.co.uk/2014/11/enabling-the-i2c-interface-on-the-raspberry-pi/


Also consider to install :  sudo apt-get install -y python3-smbus i2c-tools
Also you have to add the user to the i2c groupr sudo usermod  -aG i2c digpr  
If not member of the i2c group . cmake can not find the /dev/i2c-1  even if it is present

The  same as linux i2c dev  so with the same limitations. 

16 July 2019  I was able to read the temperature with the AT30TSE752

Consider to use a library for the Broadcom chip, but first to see how the Raspberry Pi 4 will be supported. 

## raspberry PI pico 

11 April 2022  
added in PeripheralDevices  PicoI2CInterface.h
Tested it with HTS221_tst and AT30TSE752_tst . 
But not supported the build in this package. 
build support will be done in an other repository 


## other considered platforms 

Arduino  but I never had one <br>
zynq  but this should be very similar to Linux<br>
windows . for the moment I don't see a use case , perhaps with I2C dongles ? <br>
I had a plan to use the the FDRM kl05 as a low cost I2C "dongle"  although some students worked on this it came never to a working project. <br> 
